{
    "instance": "main",
    "template": "article.show",
    "status": 200,
    "locale": "zh-CN",
    "data": {
        "article": {
            "lid": "tuwrmbke",
            "title": "Segment tree beats 的时间复杂度下限为 2log",
            "time": 1766563949,
            "author": {
                "uid": 171288,
                "avatar": "https://cdn.luogu.com.cn/upload/usericon/171288.png",
                "name": "Tony2",
                "slogan": "武器即是华服，战斗只作等闲；以坚硬的岩石为卧榻，以彻夜不休为睡眠",
                "badge": "SegBeats!",
                "isAdmin": true,
                "isBanned": false,
                "color": "Purple",
                "ccfLevel": 10,
                "xcpcLevel": 0,
                "background": "https://cdn.luogu.com.cn/upload/image_hosting/khgl1421.png"
            },
            "upvote": 76,
            "replyCount": 63,
            "favorCount": 31,
            "category": 4,
            "status": 2,
            "solutionFor": null,
            "promoteStatus": 2,
            "collection": null,
            "content": "## Part 1: Hack 方式介绍\n\n### Hack 序列如何转化到线段树上\n\n首先给出一个长度为 $len$ 的 Hack 序列，使得这个序列在进行 $O(1)$ 次的区间加操作和 $\\Theta(\\log len)$ 次的全局 $\\text{chkmax}$ 操作后变为原序列的一个轮换。因为轮换并不会影响我们进行区间加和全局 $\\text{chkmax}$ 操作（给区间加的下标同时轮换一下即可），所以可以视作序列没有改变。\n\n如果我们有了这样的序列，令 $len=n^{\\frac{1}{3}}$，并每隔 $n^{\\frac{2}{3}}$ 放一个这样的序列，每个序列刚好对应一个线段树区间。长度为 $n^{\\frac{2}{3}}$ 子树内恰好都包含了这样一个线段树区间。\n\n对 Hack 序列，进行的区间加操作是一个一个区间操作的，但是 $\\text{chkmax}$ 操作只需要全局一个指令就能一起执行。也就是一次 $\\text{chkmax}$ 操作可以递归到这 $n^{\\frac{1}{3}}$ 个 Hack 区间，每次至少调用了 $\\Omega(n^{\\frac{1}{3}}\\log n)$ 个线段树节点。而 $\\text{chkmax}$ 操作统一执行 $\\log len=\\log n$ 次，故总访问节点数为 $\\Omega(n^{\\frac{1}{3}}\\log^2 n)$。\n\n区间加操作和全局 $\\text{chkmax}$ 总共进行了 $O(n^{\\frac{1}{3}}+\\log n)=O(n^{\\frac{1}{3}})$ 次，把访问节点数除以查询（操作）次数，得到平均单次访问节点量为 $\\dfrac{\\Omega(n^{\\frac{1}{3}}\\log^2 n)}{O(n^{\\frac{1}{3}})}=\\Omega(\\log^2 n)$。\n\n### Hack 序列的构造\n\n代码可见 [Tony2 的 generator](https://www.luogu.com.cn/paste/6mx35rsn) 或 [negiizhao 的改版](https://www.luogu.com.cn/paste/tqgw5lc9)。\n\n我的 gen 里面 `vf[n]` 存的就是一个长度为 $\\text{Fib}_{2n+1}$ 的 Hack 序列。其中 $\\text{Fib}_0=0,\\text{Fib}_1=1$。\n\n将代码转化后：\n1. 对一个 $n$ 阶 Hack 序列，先将前 $\\text{Fib}_{2n}$ 个数减去 $\\text{Fib}_{2n-1}$。\n2. 全局对 $\\text{Fib}_{2n}$ 做 $\\text{chkmax}$ 操作（这里会影响到 $n$ 个不同数字，也就是说实际上可以拆解成 $n$ 次 $\\text{chkmax}$ 操作，其中 $n-1$ 次将最小值和次小值合并，触发原算法的访问条件）。\n3. 把后 $\\text{Fib}_{2n-1}$ 个数加上 $\\text{Fib}_{2n}$。\n4. 把第 $\\text{Fib}_{2n}$ 个数改成 $0$。\n\n发现此时序列恰好为原序列向右轮换 $\\text{Fib}_{2n}$ 次的结果。\n\n我们知道 $\\log\\text{Fib}_{2n+1}=O(n)$，所以这个过程中有效的 $\\text{chkmax}$ 操作确实达到了 $\\Theta(\\log len)$ 次（$len=\\text{Fib}_{2n+1}$）。而区间加和单点修改操作只有 $O(1)$ 次。满足 Hack 序列的要求。\n\n构造方式可参见代码。至于构造为什么能得到如上性质，我并不是一开始就找到序列的，是通过一个结构推得序列的。晚点写。\n\n## Part 2: 结构是什么/怎么找到的\n\n定义两种结构 $f_n,g_n$。定义两个数列 $a_n,b_n$。\n\n定义 $a,b$:\n\n$a_0=b_0=0$\n\n$a_1=b_1=1$\n\n$b_n=a_{n-1}+b_{n-1},a_n=a_{n-1}+b_n$\n\n我们发现其实 $a_n=\\text{Fib}_{2n},b_N=\\text{Fib}_{2n-1}$。\n\n定义 $f,g$:\n\n$f_0=g_0=\\{(0,1,0)\\}$\n\n$f_n=\\{(0,a_n+b_n,0)\\}\\ \\cup\\ add(f_{n-1},(0,a_n+b_n))\\ \\cup\\ add(g_{n-1},(b_n,a_n))$\n\n$g_n=f_n\\ \\cup\\ add(g_{n-1},(a_n+b_n,0))$\n\n其中三元组 $(x_1,x_2,y)$ 代表了一个线段 $(x_1,y)\\sim (x_2,y)$。操作 $add(S,(\\Delta x,\\Delta y))=\\{(x_1+\\Delta x,x_2+\\Delta x,y+\\Delta y)|(x_1,x_2,y)\\in S\\}$。\n\n首先我们要把线段理解成一个树上的 $f$ 型节点。每个 $f_n$ 都会创造出一个 $n_f$ 节点，并且其左儿子为一个 $n-1_f$ 节点，右儿子为一个 $n-1_g$ 节点。而对于 $g_n$ 来说它会创造出一个左儿子为 $n_f$ 节点、右儿子为 $n-1_g$ 的 $n_g$ 节点。\n\n注意这里 $n_f,n_g$ 的指代只是一种分类，代表一个节点的类型。一个树里面可以有很多个 $n_f$ 节点。\n\n这样交替迭代的过程生成出一棵树。假设树根为 $n_f$，我们先观察一下这个树的一些性质。\n\n树根 $n_f$ 对应的节点为 $(0,\\text{Fib}_{2n+1},0)$。\n\n$a_n+b_n=a_n+(a_{n-1}+b_{n-1})$。这意味着 $n_f$ 的左儿子和 $n_f$ 的右儿子的左儿子的根对应的线段的 $y$ 是相同的。\n\n$a_n=a_{n-1}+b_n$。这个式子之后会有作用。\n\n对树上的任意一个节点显然都有一个对应的 $x$ 区间 $[l,r]$。\n\n接下来进入最关键的部分，把树裂解成两份并重新组装。选取 $x=a_n+0.5=\\text{Fib}_{2n}+0.5$ 处将树裂开，即删除所有满足 $l\\le x< r$ 的节点。这样被删掉的节点有可能是 $f$ 节点也有可能是 $g$ 节点。\n\n奇迹出现了：被删除后，树的左侧在平面上形成了一个新的 $n-1_g$ 节点的形状。树的右侧形成了一个不完整的 $f_{n-1}$ 节点，缺少了一些线段，我们试图将其补齐：第一条要补的线段在 $y=a_n-a_{n-1}=b_n,x_1=a_n,x_2=a_n+b_n$ 处。之后的线段都满足 $x_1=a_n$，恰恰是被切开的位置。下一条线段的位置很好找：在 $y=a_n+b_{n-1}=a_n+a_{n-1}-a_{n-2}$ 处。\n\n树的左侧部分是好理解的，由于留下了 $n-1_f,n-2_f,...$，这些节点自然形成了一个 $n-1_g$ 节点。实际上这是因为 $n_g$ 是 $n_f+n-1_f+...+0_f$，这可以简单地从递推式中得到。所以这些 $n-1_f,n-2_f,...$ 就会被后缀和得到 $n-1_g,n-2_g,...$。\n\n树的右侧部分手动添加的线段为什么合法？实际上，当 $n_f$ 被删除时，留下来的是 $n_f$ 的右儿子 $n-1_g$ 的右儿子：$n-2_g$。下一个留下来的节点是 $n-3_g$。他们的 $y$ 的差是 $a_n+a_{n-1}-a_n=a_{n-1}=b_{n-1}+a_{n-2}$。为什么要拆成 $b_{n-1}+a_{n-2}$？这表明如果此时在这两个节点中间插入一个 $n-2_f$ 节点，那么它的右儿子恰好是 $n-3_g$，并且 $y$ 差了 $a_{n-2}$；父亲应当是 $n-1_f$，父亲的右儿子和左儿子的根节点的 $y$ 的差恰好是 $b_{n-1}$。这完美满足了初始构造的结构。最终我们只需要将树的两侧调整平衡（左侧减 $b_n$，因为根应该要在 $y=a_n$；右侧加 $a_n$，因为根应该要在 $y=a_n+b_n$）并左右交换，再把原本的 $(0,a_n+b_n,0)$ 补回去就得到一开始的树了。\n\n接下来我会把 $n=3$ 的情况在 GeoGebra 绘制出来。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9b1av8t7.png)\n\n这是 $3_f$ 的结构。每一条线段都代表了一个 $f$ 型节点的根。而 $g$ 型节点是隐藏的，例如 $(5,13,8),(10,13,8),(12,13,8)$ 就分别是一个 $2_g,1_g,0_g$ 节点的根。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/m06v91xt.png)\n\n当树被切开时，我们发现左侧完全就是一个 $2_g$ 结构，尽管 $(0,8,13)$ 之前并不是一个节点，但我们可以将其设置为节点了。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l6d4nta6.png)\n\n把原本被绿线切开的线段删除之后，我们补回三条红色线段。这样 $x=8$ 及其右侧就形成了一个以 $(8,13,5)$ 为根的 $2_f$ 结构。\n\n之后把左右两边调换上下平移一下就回到原本的结构了。\n\n此时我们将 Hack 序列嵌入其中。对于任意一个 $n_g$ 节点，我们会在其左端点处得到一个点 $(x,y)$，这个点的意思是序列的第 $x$ 项是 $y$。我们把这个想法标在 $n=3$ 的情况上。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/avatnlwr.png)\n\n红色的点代表着序列上的点。沿着绿线切开时，有趣的事情发生了：$(5,13),(7,13),(8,13)$ 应该成为新的红色点，因为这里出现了一个 $2_g$。但是原本的红色点在 $(5,8),(7,11),(8,12)$，我们需要对这三个位置对 $13$ 进行 $\\text{chkmax}$ 操作才能得到正确的结果。这恰好就是我们想要 Hack 的东西：操作变为对 $[1,8]$ 对 $13$ 进行 $\\text{chkmax}$ 操作。简单调整一下就变成全局 $\\text{chkmax}$ 操作了。把结构左右交换实际上是没有进行的，所以整个序列被向右轮换了 $a_n$ 轮。而图中的 $(5,8)$ 在轮换后并没有出现，但只需要令 $(13,0)$ 也是红色点就能满足条件了。\n\n## Part 3: 杂谈\n\nSegment tree beats 这个算法是 jry 老师在 2016 年提出的。但是我有点找不到我当时学这玩意看到的 ppt 了，总之就是一个背景是 AngelBeats! 的 ppt。当时很菜，根本没去理解时间复杂度。\n\n直到 11.13 我看到了 u 群有人在讨论这个问题，随即开始思考。我的第一步思考是关于一个序列的“颜色数”变化的性质。我试图刻画一个序列的未来的颜色数曲线的改变量，问题转化到了排列上，但立刻陷入了困难中。\n\n差不多之后的第二天还是第三天，我思考了关于序列建立笛卡尔树森林的想法。但是当时这个笛卡尔树没有考虑 `1 2` 这种大小关系，所以根的数量会随着区间加操作，即对树的切割，发生突变。至此又卡住了一段时间。\n\n大概又过了一两天，我想到了完整的笛卡尔树。此时树根数量的变化变得合理了，但是 chkmax 操作仍然会让树的形态发生奇奇怪怪的变化。我试图建立类似圆方树的结构直接分析各种点数的变化，却发现这样一定是徒劳的，很多信息是线性相关的。\n\n然后我发现可以通过“崩解对”来预测未来的相同颜色对的崩解。在两个树合起来的时候，会产生一些崩解对，裂开的时候会去掉一些。chkmax 操作能够让一些崩解对真正成为相同数字对。这里的三个操作成为了之后研究的基石。当时我在仅保留两个操作的情况下给出了伪证。\n\n该伪证发布之后有一些人试图去理解它。在 critno 老师的帮助下，我找到了这个证明的漏洞，证明崩塌了。在长时间的打补丁失败之后，我试图进行 hack。我发现了一种 hack 思路，其思路形如并查集，但是我却发现中间漏掉了 chkmax 操作会将崩解对“合并”的性质，hack 爆炸了。\n\n至此陷入了长时间的挣扎时间。在“合并”性质的帮助下，整个结构显得无懈可击；同时操作又有高达三个，去掉任何一个或者任何一个性质都会直接得到错误的 hack。中间思考过“怎样的 1 3 步骤是对 2 步骤合法”的问题以及“是否存在一个模型使得 加入一条链后 包括确认，删除的次数减少？”的问题，都没法得到合理解释。\n\n最终撬开裂缝的是一个性质：单次添加的崩解对形成的链一定是从上到下染色并被删除的。模型更正为一个类似于圆方树的并查集模型，立刻能看到 hack 的希望了。也就是这几天左右，我学习了并查集 hack 单路径压缩的方法，并套用到了这个上面；在因为写普物作业而昏头想错一天之后，终于在 12.23 找到了非常接近 hack 的结构。\n\n这一天我非常激动，因为我感觉离终点已经非常近了。创造结构，填写各项数值，解出数值的递推式，最终获得了在 0.618 处进行区间加操作的优美结构。这一次终于不会再假了，1log 的证明已经不会再存在了。\n\n之后应该已经有一些人理解了这个 hack，但要理解这个 hack 怎么来的应该有点困难。我是在草稿纸上画了很多张图才和室友 zxb 解释清楚 hack 的原理的。之后我会把这些图都补上去方便大家理解。",
            "contentFull": true,
            "adminNote": null
        },
        "favored": false,
        "voted": null,
        "canReply": false,
        "canEdit": false
    },
    "user": null,
    "time": 1766632256.219466,
    "theme": null
}